"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const stream = __importStar(require("stream"));
const readline_1 = __importDefault(require("readline"));
const sauce_json_reporter_1 = require("@saucelabs/sauce-json-reporter");
const testcomposer_1 = require("@saucelabs/testcomposer");
const api_1 = require("./api");
const ci_1 = require("./ci");
// Once the UI is able to dynamically show videos, we can remove this and simply use whatever video name
// the framework provides.
const VIDEO_FILENAME = 'video.mp4';
class Reporter {
    constructor(cypressDetails, opts = { region: testcomposer_1.Region.USWest1 }) {
        let reporterVersion = 'unknown';
        try {
            const packageData = JSON.parse(fs_1.default.readFileSync(path_1.default.join(__dirname, '..', 'package.json'), 'utf-8'));
            reporterVersion = packageData.version;
            // eslint-disable-next-line no-empty
        }
        catch (e) {
        }
        if (!opts.region) {
            opts.region = testcomposer_1.Region.USWest1;
        }
        this.opts = opts;
        this.testComposer = new testcomposer_1.TestComposer({
            region: this.opts.region || testcomposer_1.Region.USWest1,
            username: process.env.SAUCE_USERNAME || '',
            accessKey: process.env.SAUCE_ACCESS_KEY || '',
            headers: { 'User-Agent': `cypress-reporter/${reporterVersion}` }
        });
        this.testRunsApi = new api_1.TestRuns({
            region: this.opts.region || testcomposer_1.Region.USWest1,
            username: process.env.SAUCE_USERNAME || '',
            accessKey: process.env.SAUCE_ACCESS_KEY || '',
        });
        this.cypressDetails = cypressDetails;
        this.videoStartTime = process.env.SAUCE_VIDEO_START_TIME ?
            new Date(process.env.SAUCE_VIDEO_START_TIME).getTime() : undefined;
    }
    // Reports a spec as a Job on Sauce.
    async reportSpec(result) {
        let suiteName = result.spec.name;
        if (this.opts.build) {
            suiteName = `${this.opts.build} - ${result.spec.name}`;
        }
        const stats = result.stats;
        const job = await this.testComposer.createReport({
            name: suiteName,
            startTime: stats.wallClockStartedAt || result.stats.startedAt || '',
            endTime: stats.wallClockEndedAt || stats.endedAt || '',
            framework: 'cypress',
            frameworkVersion: this.cypressDetails?.cypressVersion || '0.0.0',
            passed: result.stats.failures === 0,
            tags: this.opts.tags,
            build: this.opts.build,
            browserName: this.cypressDetails?.browser?.name,
            browserVersion: this.cypressDetails?.browser?.version,
            platformName: this.getOsName(this.cypressDetails?.system?.osName)
        });
        const consoleLogContent = this.getConsoleLog(result);
        const screenshotsPath = result.screenshots.map((s) => s.path);
        const report = await this.createSauceTestReport([{
                spec: result.spec,
                tests: result.tests,
                video: result.video,
                screenshots: result.screenshots
            }]);
        await this.uploadAssets(job.id, result.video, consoleLogContent, screenshotsPath, report);
        return job;
    }
    // Reports a spec as a TestRun to Sauce.
    async reportTestRun(result, jobId) {
        const runs = result.tests
            .filter((test) => test.attempts.length > 0)
            .map((test) => {
            const attempt = test.attempts[test.attempts.length - 1];
            const startDate = new Date(attempt.wallClockStartedAt);
            const endDate = new Date(startDate.valueOf() + attempt.wallClockDuration);
            const req = {
                name: test.title.join(' '),
                start_time: attempt.wallClockStartedAt,
                end_time: endDate.toISOString(),
                duration: attempt.wallClockDuration,
                browser: `${this.cypressDetails?.browser?.name} ${this.cypressDetails?.browser?.version}`,
                build_name: this.opts.build,
                ci: {
                    ref_name: ci_1.CI.refName,
                    commit_sha: ci_1.CI.sha,
                    repository: ci_1.CI.repo,
                    branch: ci_1.CI.refName,
                },
                framework: 'cypress',
                platform: 'other',
                os: this.getOsName(this.cypressDetails?.system?.osName),
                sauce_job: {
                    id: jobId,
                },
                status: stateToStatus(test.state),
                tags: this.opts.tags,
                type: 'web',
            };
            if (attempt.error) {
                const err = attempt.error;
                req.errors = [
                    {
                        message: err.message,
                        path: err.codeFrame?.originalFile,
                        line: err.codeFrame?.line,
                    },
                ];
            }
            return req;
        });
        await this.testRunsApi.create(runs);
    }
    async uploadAssets(jobId, video, consoleLogContent, screenshots, testReport) {
        const assets = [];
        // Since reporting is made by spec, there is only one video to upload.
        if (video) {
            assets.push({
                data: fs_1.default.createReadStream(video),
                filename: VIDEO_FILENAME,
            });
        }
        // Add generated console.log
        const logReadable = new stream.Readable();
        logReadable.push(consoleLogContent);
        logReadable.push(null);
        const reportReadable = new stream.Readable();
        reportReadable.push(testReport.stringify());
        reportReadable.push(null);
        assets.push({
            data: logReadable,
            filename: 'console.log',
        }, {
            data: reportReadable,
            filename: 'sauce-test-report.json',
        });
        // Add screenshots
        for (const s of screenshots) {
            assets.push({
                data: fs_1.default.createReadStream(s),
                filename: path_1.default.basename(s)
            });
        }
        await this.testComposer.uploadAssets(jobId || '', assets).then((resp) => {
            if (resp.errors) {
                for (const err of resp.errors) {
                    console.error('Failed to upload asset:', err);
                }
            }
        }, (e) => console.error('Failed to upload assets:', e.message));
    }
    getConsoleLog(result) {
        let consoleLog = `Running: ${result.spec.name}\n\n`;
        const tree = this.orderContexts(result.tests);
        consoleLog = consoleLog.concat(this.formatResults(tree));
        consoleLog = consoleLog.concat(`
      
  Results:

    Tests:        ${result.stats.tests || 0}
    Passing:      ${result.stats.passes || 0}
    Failing:      ${result.stats.failures || 0}
    Pending:      ${result.stats.pending || 0}
    Skipped:      ${result.stats.skipped || 0}
    Screenshots:  ${result.screenshots.length || 0}
    Video:        ${result.video != ''}
    Duration:     ${Math.floor(result.stats.duration / 1000)} seconds
    Spec Ran:     ${result.spec.name}

      `);
        consoleLog = consoleLog.concat(`\n\n`);
        return consoleLog;
    }
    orderContexts(tests) {
        let arch = { name: '', values: [], children: {} };
        for (const test of tests) {
            arch = this.placeInContext(arch, test.title, test);
        }
        return arch;
    }
    placeInContext(arch, title, test) {
        if (title.length === 1) {
            arch.values.push({ title: title[0], result: test });
            return arch;
        }
        const key = title[0];
        if (!arch.children[key]) {
            arch.children[key] = { name: key, values: [], children: {} };
        }
        arch.children[key] = this.placeInContext(arch.children[key], title.slice(1), test);
        return arch;
    }
    formatResults(node, level = 0) {
        let txt = '';
        const padding = '  '.repeat(level);
        txt = txt.concat(`${padding}${node.name}\n`);
        if (node.values) {
            for (const val of node.values) {
                const ico = val.result.state === 'passed' ? '✓' : '✗';
                const attempts = val.result.attempts;
                const duration = attempts[attempts.length - 1].wallClockDuration;
                txt = txt.concat(`${padding} ${ico} ${val.title} (${duration}ms)\n`);
            }
        }
        for (const child of Object.keys(node.children)) {
            txt = txt.concat(this.formatResults(node.children[child], level + 1));
        }
        return txt;
    }
    getOsName(osName) {
        if (!osName) {
            return 'unknown';
        }
        if ('darwin' === osName) {
            return 'Mac';
        }
        return osName;
    }
    async createSauceTestReport(results) {
        const run = new sauce_json_reporter_1.TestRun();
        for (const result of results) {
            const specSuite = run.withSuite(result.spec.name);
            if (result.video) {
                specSuite.attach({ name: 'video', path: VIDEO_FILENAME, contentType: 'video/mp4' });
            }
            // inferSuite returns the most appropriate suite for the test, while creating a new one along the way if necessary.
            // The 'title' parameter is a bit misleading, since it's an array of strings, with the last element being the actual test name.
            // All other elements are the context of the test, coming from 'describe()' and 'context()'.
            const inferSuite = (title) => {
                let last = specSuite;
                title.forEach((subtitle, i) => {
                    if (i === title.length - 1) {
                        return;
                    }
                    last = last.withSuite(subtitle);
                });
                return last;
            };
            for (const t of result.tests) {
                const name = t.title[t.title.length - 1];
                const suite = inferSuite(t.title);
                const attempt = t.attempts[t.attempts.length - 1];
                const code = await getCodeBody(result.spec.name, t);
                // If results are from 'after:run', 'wallClockDuration' and 'wallClockStartedAt' properties are called 'duration' and 'startedAt'
                const startTime = attempt.wallClockStartedAt || attempt.startedAt;
                const duration = attempt.wallClockDuration || attempt.duration;
                let videoTimestamp;
                if (this.videoStartTime) {
                    videoTimestamp = (new Date(startTime).getTime() - this.videoStartTime) / 1000;
                }
                const tt = suite.withTest(name, {
                    status: stateToStatus(t.state),
                    duration,
                    startTime,
                    output: errorToString(attempt.error),
                    code: new sauce_json_reporter_1.TestCode(code),
                    videoTimestamp,
                });
                // If results are coming from `after:spec`, the screenshots are attached to the spec results. But we can
                // re-associate the screenshots back to their tests via the testId.
                result.screenshots?.forEach((s) => {
                    if (s.testId === t.testId) {
                        tt.attach({ name: 'screenshot', path: path_1.default.basename(s.path), contentType: 'image/png' });
                    }
                });
                // If results are coming from `after:run`, the screenshots are attached to each `attempt`.
                attempt.screenshots?.forEach((s) => {
                    tt.attach({ name: 'screenshot', path: path_1.default.basename(s.path), contentType: 'image/png' });
                });
            }
        }
        run.computeStatus();
        return run;
    }
}
exports.default = Reporter;
async function getCodeBody(specName, test) {
    // check if it's a cucumber test
    const regex = new RegExp('.*.feature$');
    if (!regex.test(specName)) {
        return test.body.split("\n");
    }
    if (test.attempts.length === 0 || !test.attempts[0].error || !test.attempts[0].error.codeFrame) {
        return [];
    }
    // get cucumber test code info
    const errInfo = test.attempts[0].error;
    if (!fs_1.default.existsSync(errInfo.codeFrame.originalFile)) {
        return [];
    }
    return await processLine(errInfo.codeFrame.originalFile, errInfo.codeFrame.line);
}
async function processLine(filename, n) {
    const min = Math.max(0, n - 3);
    const max = n + 3;
    const fileStream = fs_1.default.createReadStream(filename);
    const rl = readline_1.default.createInterface({
        input: fileStream,
        crlfDelay: Infinity,
    });
    let cursor = 0;
    const content = [];
    for await (const line of rl) {
        if (cursor >= min && cursor <= max) {
            content.push(line);
            rl.close();
        }
        cursor++;
    }
    return content;
}
function errorToString(error) {
    if (!error) {
        return error;
    }
    const frame = error.codeFrame?.frame || "";
    return `${error.name}: ${error.message}

${frame}`;
}
/**
 * Translates cypress's state to the Sauce Labs Status.
 * @param state the cypress state of the test
 * @returns Status
 */
function stateToStatus(state) {
    switch (state) {
        case 'passed':
            return sauce_json_reporter_1.Status.Passed;
        case 'failed':
            return sauce_json_reporter_1.Status.Failed;
        case 'pending':
            return sauce_json_reporter_1.Status.Skipped;
        case 'skipped':
            return sauce_json_reporter_1.Status.Skipped;
        default:
            return sauce_json_reporter_1.Status.Skipped;
    }
}
